package edu.umd.cs.guitar.ripper;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;
import java.util.Set;
import java.util.StringTokenizer;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import org.openqa.selenium.*;
import org.openqa.selenium.htmlunit.HtmlUnitDriver;


/**
 * This class will extract links from a website. It will
 * use a configuration file to determine which tags from
 * the site it will extract. After every link has been 
 * extracted it will write and xml document that follows
 * the GUI structure schema.
 * 
 * @author Team Web
 * @version 1.0
 * @since 1.0
 *
 */
public class WebRipper {
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+ 						PROPERTIES								+
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
	/** 
	 * toExtractLinks - Links that still need to be crawled
	 * extractedLinks - Links that have been crawled
	 */
	private ArrayList<String> toExtractLinks, extractedLinks;
	
	/**
	 * width - specifies how many links on a page we will click
	 * depth - specifies how deep into pages we will go
	 */
	private int width, depth;
	
	/**
	 *  the final xml document we will output (this is what will use to create
	 * elements and to output the final xml)
	 */
	private Document guiXML;
	
	/**
	 *  stores the guiXML as a String for testing purposes
	 */
	private String guiXmlString;
	
	/**
	 *  Document Builder Factory for necessary for creating XML
	 */
	private DocumentBuilderFactory docFactory;
	
	/**
	 *  Document Builder necessary for creating XML
	 */
	private DocumentBuilder docBuilder;
	
	/**
	 *  the root node in the gui xml (this is what we will append to)
	 */
	private Element root;
	
	/** contains tags we will extract and its properties. this also
	 * specifies what gui tag will be associated with it
	 */
	private HashMap<String, HashMap<String, Object>> configHash;
	
	/**
	 *  the name of the configuration file
	 */
	private final String CONF_FILE = "/resources/config/ripperConfigFile";
	
	/**
	 *  This is our webdriver to extract links
	 */
	private HtmlUnitDriver driver;
	
	/**
	 *  List of all the tags we want to find
	 */
	private ArrayList<Tag> tags;
		
	/**
	 *  Counter to generate unique IDs for widgets and containers
	 */
	private int idCounter = 0;
	
	/**
	 *  This determines weather we want to output debug statements
	 */
	private boolean verbose;
	
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+ 						MAIN METHODS							+
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
	/**
	 * This is the main constructer of WebRipper. This will init
	 * all class properties.
	 * 
	 * @param url 	The url of the root website
	 * @param w		The width of how many links to crawl
	 * @param d		The depth of how many websites to crawl
	 * 
	 * @author Luis Sanchez
	 * @since 1.0
	 */
	public WebRipper(String url, int w, int d, boolean v){
		width = w;
		depth = d;
		extractedLinks = new ArrayList<String>();
		toExtractLinks = new ArrayList<String>();
		toExtractLinks.add(url);
		driver = new HtmlUnitDriver();

		// Setup XML document (guiXML)
		try {
			docFactory = DocumentBuilderFactory.newInstance();
			docBuilder = docFactory.newDocumentBuilder();
			guiXML = docBuilder.newDocument();
			root = guiXML.createElement("GUIStructure");
			guiXML.appendChild(root);
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		}
		
		setTags();
		//parseConfigFile();
		crawler(url);
	}
	
	/**
	 * Crawls a website starting at url, converts all pages' elements into a GUI.xml file
	 * 
	 * @param url 	The url of the root website
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	protected void crawler(String url){
		
		// for phase 1, simply "extract" elements from the base url, and ignore its sub-pages
		extract(url);
		
		// close XML file and write to file (currently writes to System.out for convenient debugging)
		try {
		  	TransformerFactory transformerFactory = TransformerFactory.newInstance();
		  	Transformer transformer = transformerFactory.newTransformer();
		  	DOMSource source = new DOMSource(guiXML);
		  	
		  	// Output guiXML to System.out
		  	StreamResult result =  new StreamResult(System.out);
		    transformer.transform(source, result);
		    
		    // Output guiXML to String (for testing purposes)
		    StringWriter sw = new StringWriter();
		    result = new StreamResult(sw);
		    transformer.transform(source, result);
		    this.guiXmlString = sw.toString();
		    
		    // Output guiXML to GUI.xml file
		    /* result = new StreamResult(new File("GUI.xml"));
		    transformer.transform(source, result); */
			BufferedWriter out = new BufferedWriter(new FileWriter("GUI.xml"));
			out.write(this.guiXmlString);
			out.close();
		    
		} catch (TransformerConfigurationException e) {
			e.printStackTrace();
		} catch (TransformerException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Returns a list of all links in url, and extracts page elements and appends them as a <GUI> to guiXML
	 * 
	 * @param url 	The url of the root website
	 * 
	 * @return An ArrayList of String objects containing the all the links in url
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	protected ArrayList<String> extract(String url){
		ArrayList<String> urls = new ArrayList<String>();

		ArrayList<WebElement> elements = new ArrayList<WebElement>();
		
		driver.get(url);
		
		// create <GUI> element
		Element guiTag = createGuiElement();
		root.appendChild(guiTag);
		
		// create <Window> element
		Element windowTag = createWindowElement();
		Element attributesTag = createAttributesElement();
		guiTag.appendChild(windowTag);
		windowTag.appendChild(attributesTag);
		
		// populate <Window> attributes
		attributesTag.appendChild(createPropertyElement("URL", driver.getCurrentUrl()));
		attributesTag.appendChild(createPropertyElement("Title", driver.getTitle()));

		// extract page widgets into <Container><Contents>
		Element containerTag = createContainerElement();
		Element contentsTag = createContentsElement();
		guiTag.appendChild(containerTag);
		containerTag.appendChild(contentsTag);
		
		for (Tag tag : tags){
			String tagName = tag.getTag();
			elements = (ArrayList<WebElement>)driver.findElementsByTagName(tagName);
			for (WebElement el : elements){
				
				// populate list of links in url page
				if (tagName.equals("a"))
					if (el.getAttribute("href").contains("http://")) // sometimes links are based on the current page's directory, and are not complete URLs
						urls.add(el.getAttribute("href"));
					else
						urls.add(driver.getCurrentUrl() + el.getAttribute("href"));
							
				// create widget or container based on tag
				if (tag.getType().equals("widget")) {
					Element widgetTag = createWidgetElement();
					Element widgetAttributesTag = createAttributesElement();
					contentsTag.appendChild(widgetTag);
					widgetTag.appendChild(widgetAttributesTag);
					
					// populate widget attributes
					widgetAttributesTag.appendChild(createPropertyElement("ID", "id" + idCounter++));
					widgetAttributesTag.appendChild(createPropertyElement("Tag", tag.getTag()));
					
					// properties of a specific tag
					for (String property : tag.getProperties()) {
						widgetAttributesTag.appendChild(createPropertyElement(property,el.getAttribute(property)));
					}
				} else if (tag.getType().equals("container")) {
					// ?
				}
			}
		}
		
		return urls;
	}
	
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+ 						HELPER METHODS							+
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
	/**
	 * Parses the configuration file and places values into a hash
	 * 
	 * @author Luis Sanchez
	 * @since 1.0
	 */
	private void parseConfigFile(){
		try {
			FileInputStream fis = new FileInputStream(CONF_FILE);
			Scanner s = new Scanner(fis);
			
			while(s.hasNextLine()){
				HashMap<String, Object> val = new HashMap<String, Object>();
				String line = s.nextLine();
				
				//Remove Comments
				int index = line.indexOf('#');
				line = line.substring(0, index);
				
				//If line is not a comment then process
				if(line.length() > 0){
					StringTokenizer st = new StringTokenizer(line);
					StringTokenizer props = new StringTokenizer(st.nextToken(";"));
					String htmlTag = props.nextToken(":");
					ArrayList<String> list = new ArrayList<String>();
					
					val.put("guiTag", st.nextToken());
					
					while(props.hasMoreTokens()){
						list.add(props.nextToken(":"));
					}
					
					val.put("properties", list);
					
					configHash.put(htmlTag, val);
				}
			}
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} 
	}
	
	/**
	 * Helper function to create <GUI> element
	 * 
	 * @return An Element object
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	private Element createGuiElement() {
		Element attributesElement = guiXML.createElement("GUI");
		return attributesElement;
	}
	
	/**
	 * Helper function to create <Window> element
	 * 
	 * @return An Element object
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	private Element createWindowElement() {
		Element attributesElement = guiXML.createElement("Window");
		return attributesElement;
	}
	
	/**
	 * Helper function to create <Container> element
	 * 
	 * @return An Element object
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	private Element createContainerElement() {
		Element attributesElement = guiXML.createElement("Container");
		return attributesElement;
	}
	
	/**
	 * Helper function to create <Contents> element
	 * 
	 * @return An Element object
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */ 
	private Element createContentsElement() {
		Element attributesElement = guiXML.createElement("Contents");
		return attributesElement;
	}
	
	/**
	 * Helper function to create <Widget> element
	 * 
	 * @return An Element object
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	private Element createWidgetElement() {
		Element attributesElement = guiXML.createElement("Widget");
		return attributesElement;
	}
	
	/**
	 * Helper function to create <Attributes> element
	 * 
	 * @return An Element object
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	private Element createAttributesElement() {
		Element attributesElement = guiXML.createElement("Attributes");
		return attributesElement;
	}
	
	/**
	 * Helper function to create: <Property><Name>name</Name><Value>value</Value></Property>
	 * 
	 * @return An Element object
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	private Element createPropertyElement(String name, String value) {
		Element propertyElement = guiXML.createElement("Property");
		Element nameElement = guiXML.createElement("Name");
		Element valueElement = guiXML.createElement("Value");
		nameElement.setTextContent(name);
		valueElement.setTextContent(value);
		propertyElement.appendChild(nameElement);
		propertyElement.appendChild(valueElement);
		return propertyElement;
	}
	
	/**
	 * Sets the tags based on the tagConfig.xml file
	 * 
	 * @author Brian Ramnarain
	 * @since 1.0
	 * 
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 */
	private void setTags() {
		tags = new ArrayList<Tag>();
		DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();
		DocumentBuilder p = null;
		try {
			p = f.newDocumentBuilder();
		} catch (ParserConfigurationException e) {// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		Document doc = null;
		try {
			doc = p.parse("tagConfig.xml");
		} catch (SAXException e) {e.printStackTrace();
		} catch (IOException e) {e.printStackTrace();
		}
		
		Element docElement = doc.getDocumentElement();
		NodeList tagList = docElement.getChildNodes();
		
		
		for(int i = 0; i < tagList.getLength(); ++i) {
			Node command = tagList.item(i);
		    String commandName = command.getNodeName();
		    if (commandName == "Tag"){
		    	NamedNodeMap attributes = command.getAttributes();
		    	String name = attributes.getNamedItem("name").getNodeValue();
		    	String type = attributes.getNamedItem("type").getNodeValue();
		    	Tag tag = new Tag(name,type);
		    	Integer propIndex = 1;
		    	Node property = attributes.getNamedItem(("property" + propIndex.toString()));
		    	while(property != null){
		    		String propertyName = property.getNodeValue();
		    		tag.addProperty(propertyName);
		    		propIndex++;
		    		property = attributes.getNamedItem(("property" + propIndex.toString()));
		    	}
		    	tags.add(tag);
		    }
		}
		System.out.println(tags);
	}
	
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//+ 					DEBUG/PRINT METHODS							+
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	/**
	 * Returns the current guiXML as a string. If a website has not been ripped, this method will return null.
	 * 
	 * @return A String of the current guiXML
	 * 
	 * @author Todd Watson
	 * @since 1.0
	 */
	public String getXmlString() {
		return this.guiXmlString;
	}
	
	/**
	 * Prints out the config hash in a human readable way
	 * 
	 * @author Luis Sanchez
	 * @since 1.0
	 */
	@SuppressWarnings("unchecked")
	private void printConfigHash(){
		Set<String> keys = configHash.keySet();
		
		System.out.println("*******************************************");
		
		for(String htmlTag : keys){
			HashMap<String, Object> hash = configHash.get(htmlTag);
			String guiTag = (String)hash.get("guiTag");
			ArrayList<String> props = (ArrayList<String>)hash.get("properties");
			
			System.out.println("HTML Tag: " + htmlTag);
			System.out.println("GUI tag: " + guiTag);
			System.out.println("Properties: ");
			for(String p : props)
				System.out.println("\t" + p);
			
			System.out.println("*******************************************");
		}
	}
}
